---
layout: posts
title: chapter12. System Automation
date: 2019-02-26 15:38:36 +0900
type: posts
published: true
comments: true
categories: [se]
tags: [System, Server]
---


* 학습목표
    * 명령어의 예약 실행 방법
    * root 로그인을 자동화하기 위한 SSH와 버클리의 r-명령어 사용법
    * SSH 공개키 인증 매커니즘의 작용방식
    * 파일 동기화 자동화하기 위한 rdist, rsync 및 기타 툴 사용법
    * 로컬 설정 파일을 관리해주는 cfengine의 설정과 사용법
    * 임시 공간의 관리를 자동화해 주는 기법
    * 로그 파일을 순환시켜 주는 logrotate의 사용법

1. 스케줄링 툴: 각 프로세스가 실행되더야 할 때를 결정해 주는 하나 이상의 스케줄링 툴을 사용함으로써 대부분의 프로세스를 쉽게 자동화할 수 있다. 보통 두가지가 기본적으로 있는데 at과 cron이다. at이 매리의 특정 시간에 일어날 일회성 작업을 스케줄링할 수 있는 반면, cron은 반복적인 작업을 스케줄링 한다. 
    1. at를 이용한 일회 스케줄링: at은 매우 간단하게 특정 시간에 명령어가 동작하도록 스케줄링할 수 있다. `at 5:30 pm kill -9 19072 <EOT> ##ctrl-D로 명령어 종료시킬 수 있음`
    2. cron을 이용한 정기적 예약 작업: cron은 crontab에 설정된 스케줄대로 정기적으로 명령어를 실행해 준다. crontab은 스케줄된 cron 작업을 저장하는 파일이다. crontab은 스케줄된 cron작업을 저장하는 파일이다. 각 계정은 각 계정의 crontab 파일을 가진다 crontab -e를 실행하면, 명령어를 실행한 사용자의 crontab을 편집할 수 있는 에디터가 실행된다. `* * * * * /usr/lib/newsyslog` 라하면 분,시,일,월,요일(0이 일요일),명령어 순이다. 여러번 하려면 컴마를 사용하면 되고 5분마다 2시간마다 처럼 간격을 나타내려면 /5 /2로 처리해주면 된다.
    3. at과 cron의 출력 리다이렉션: ` 30 1 * * * /usr/local/bin/cleanup > /dev/null 2>&1` /dev/null은 예약 작업의 출력 결과를 무시하고 싶을 때 사용 2>&1은 표준 출력뿐만 아니라 표준 에러도 /dev/null로 리 다이렉션 해준다.
    4. at과 cron의 접근제어: at과 cron은 매우 유용한 예약 작업 툴이긴 하지만, 허가받지 않은 사용자가 이러한 특권을 너무 쉽게 남용할 수 있다. 그래서 at과 cron 모두 'allow'와 'deny' 파일을 지원한다. 이 파일을 이용하면 특정 사용자에 대하여 스케줄링 툴의 사용을 허용하거나 거부할 수 있다.  
2. root 사용자로의 로그인 자동화: 대부분의 관리 작업에는 어느 정도 root 권한을 필요로 한다. 한 컴퓨터에서 root권한으로 원격의 프로세스를 실행할 필요가 있거나 혹은 root 권한으로 파일을 다른 컴퓨터로 복사할 필요가 생기는 다중 시스템 환경이라면 상황이 복잡해진다. interactive한 환경이라면 원격에 컴퓨터로 로그인하면 되지만 자동화 할 수는 없다. 그렇다고 스크립트 파일에 패스워드를 넣어두는 것은 바람직하지 않다.
    1. 패스워드가 필요하지 않은 버클리의 r-명령어 사용: 원격 시스템에 있는 명령어를 실행하는 가장 오래된 방법은 버클리의 r- 명령어이다. 세 개의 r-명령어가 원격 시스템에서 작업을 수행할 수 있다. rcp(원격 시스템으로 또는 원격 시스템으로부터 파일을 복사한다.), rlogin(원격 시스템에 로그인한다.), rsh(원격 시스템의 명령어를 실행한다.) r-명령어를 이용하면 패스워드를 사용하지 않고 원격 컴퓨터에 로그인하거나 프로세스를 실행할 수 있다. 단지 원격 서버에 있는 두개의 설정파일, /etc/hosts.equiv와 .hosts 파일이 이런 접근을 제어한다. 두파일은 다음과 같은 형식으로 신뢰하는 호스트와 사용자를 명시항 행을 포함한다. `호스트명 [사용자명]` 호스트명은 패스워드를 사용하지 않고 원격 로그인이 허용된 호스트의 이름을 지정하며, 사용자명은 선택사항으로 로그인을 허용할 원격 호스트의 사용자명을 지정하게 된다. 사용자명이 하나도 명시되지 않으면, 그 호스트의 모든 사용자들이 패스워드 없이 로그인할 수 있도록 허용하는 것이다. r-명령어를 사용하는데 있어 유일한 요구사항은 사용자의 UID가 반드시 양쪽의 컴퓨터에서 동일해야만 한다는 것이다. /etc/hosts.equiv 파일은 컴퓨터에 있는 모든 사용자로의 접근 규칙을 제어하는 것이다. .hosts 파일은 사용자의 홈 디렉토리에 있게 되며, 단지 그 사용자 계정으로의 접근을 제어하게 된다. 보안을 높이기 위해서, /etc/hosts.equiv 파일은 반드시 root가 소유권을 가지고 있어야 하며, .hosts파일은 접근을 하게되는 사용자가 소유권을 가져야 한다. 예제를 살펴보면 원격의 컴퓨터 server1의 Jeremy를 그 자신의 계정으로 접근할 수 있도록 하려면, 다음을 Jeremy의 .hosts파일에 추가한다. `server1` 임의의 원격 호스트의 사용자 Jason과 Scott가 로컬 시스템의 어느 계정으로 접근할 수 있도록 하려면, 다음을 /etc/hosts.equiv 파일에 추가한다. `+ jason scott`
    2. SSH 사용: ssh는 암호화된 채널을 이용할 수 있을 뿐만 아니라 공개키 인증 기능을 제공하는데, 공개키 인증 기능을 이용하여 패스워드 없이 로그인할 수 있다.`ssh-keygen -t rsa -b 1024` 한쌍의 1,024비트짜리 RSA키를 생성한 것이다. 비밀키는 /.ssh/id_rsa에 저장하고 공개키는 /.ssh/id_rsa.pub에 저장하게 된다. 보안을 높이기 위해서 SSH는 비밀키를 암호화하는데 사용하는 passphrase를 지원하지만, 자동화를 위해서는 빈 패스프레이즈를 사용해서 키를 암호화하지 않는다. 비밀키의 민감한 특성상 비밀키 파일은 오직 root만 읽을 수 있도록 되어 있지만, `cat /home/user/.ssh/my_ssh_key.pub` 이 공개키는 배포를 위한 것이므로 사람이 읽을 수 있는 형식으로 저장된다. ` scp -p ~/.ssh/id_dsa.pub root@ip:~/.ssh/authorized_keys2` 다음 단계는 root로 로그인 하기를 원하는 각 서버에 있는 root의 authorized_keys 파일에 이 공개키를 추가한 것이다. 이 파일에 있는 공개키들은 root임을 인증하는데 사용할 수 있는 비밀키가 어느 것인가를 지시한다. 이 단계를 마쳤다면, 새로 생성한 비밀키에 접근할 수 있는 사람은 누구나 이들 서버에서 root권한으로 명령어를 실행할 수 있게 된다. 
3. 파일 동기화 자동화: 수백대의 컴퓨터의 파일을 관리하는 것은 어려울 것이다. 그러므로 파일 동기화 매커니즘은 우너격 서버에 있는 파일들을 주파일 저장소와 일치되게 함으로써, 시스템 관리자가 이런 파일들에 대한 유지보수 작업과 분배작업을 쉽게 할 수 있도록 해준다. rcp, scp, rsync, rdist는 이를 도와준다. rcp와 scp는 명령행에서 명시적으로 지정한 개별파일 이나 디렉토리를 복사하고, 반면에 rsync와 rdist는 소프트웨어 저장소나 시스템 설정 파일과 같은 파일 집합체의 분배 관리에 가장 잘 사용된다.
    1. rcp와 scp를 이용한 파일 복사: `scp [-rp] 출발지(사용자명@호스트:경로) 목적지` 예로 들면 server2에 있는 /etc/group을 server1으로 복사하려면 `scp -rp server2:/etc/group /etc/group` 또 server1에 있는 /usr/local/bin 디렉토리 전체를 server2의 사용자 adam권한으로 복사하려면 `scp -r /usr/local/bin adam@server2:/usr/testing`이고 -r은 디렉토리 -p는 원 소유권과 허가권 보존.
    2. rsync를 이용한 파일 동기화: rsync는 청크 단위로 파일을 비교하고 변경이 있는 청크만 전송하게 된다. `rsync -e ssh -avzp 전송할 파일 경로 root@ip:파일경로`
    3. rdist를 이용한 파일 분배:
    4. rdist 명령어 실행
4. cfengine을 이용한 로컬 설정 자동화
    1. cfengine의 여러 실행 유형
    2. cfengine의 설정
5. 임시 공간의 관리 자동화
    1. find를 이용한 임시 공간 관리
    2. cfengine을 이용한 임시 공간 관리
6. 로그 관리 작업의 자동화
7. 일반적인 로그 순환 관리 툴인 logrotate 이용
