---
layout: posts
title: chapter11. Performance Tuning - Disk
date: 2019-02-26 15:37:36 +0900
type: posts
published: true
comments: true
categories: [se]
tags: [System, Server]
---


4. 저장장치의 성능과 용량 측정
    * 저장 장치의 성능, 특히 하드디스크의 성능은 시스템의 성능에 필수적인 요소가 되는데 이는 운영체제와 애플리케이션 그리고 애플리케이션의 데이터를 포함한 모든 것이 하드디스크에 저장되기 때문이다. 또한 스왑핑이 잘못되면 시스템의 성능을 심각하게 손상시키게 될 것이다. 저장장치의 성능과 용량을 평가하고 최적화하는 방법을 완전하게 이해하기 위해서는 용량, 디스크 아키텍처, 대역폭, 지연대기(Latency), 순차 접근(sequential access)과 임의 접근(Random access), 블록(block) I/O와 캐릭터(character) I/O, INODE와 같은 저장 장치의 기본적인 개념과 용어를 먼저 이해해야만 한다. 
    1. 저장장치의 용량의 이해: 메모리에서 1킬로바이트는 1024바이트지만 디스크에서는 1킬로바이트를 1000바이트로 한다.
    2. 디스크 아키텍처: 플래터, 트랙, 섹터, 실린더
    3. 대역폭 대 지연대기: 데이터를 디스크에서 읽어 프로세스로 보내는데 걸리는 시간은 대역폭과 지연대기라는 두가지 주요 스펙에 의해 영향을 받는다. 대역폭은 특정 시간 동안 디스크로 읽고 쓸 수 있는 데이터의 양이다. 디스크 채널은 최대 대역폭이라는 스펙을 가지게 된다. 지연대기는 읽기 혹은 쓰기 요청이 일어난 시간부터 실제 디스크에 의해 요청의 처리가 완료될 때까지 걸린 시간을 말한다. 지연대기 일으키는 요소는 디스크 플래터의 회전속도, 디스크 헤드의 이동속도, 안쪽 플래터에서 바깥쪽 플래터까지의 거리, 디스크 i/o의 큐잉 전략에 따라 다르다.
    4. 순차 접근 대 임의 접근
    5. 블록 i/o 대 캐릭터 i/o: 디스크의 물리적인 특성으로 인하여 한번에 한 바이트보다는 블록 단위로 저장하거나 읽고 쓰는 것이 합리적일 것이다. 이것이 블록i/o 이고 한번에 한 바이트씩 처리하는 방식인 character i/o 또는 raw i/o가 있다.
    6. Inode: Inode는 index nodes 축약어로서 모든 유닉스 파일 시스템에서 파일과 디렉토리에 관한 메타데이터를 저장하는데 사용된다. 메타데이터에는 파일의 소유권과 허가권, 마지막 수정시간과 크기가 포함된다. 대부분의 파일 시스템에서 Inode는 파일 시스템이 생성될때 미리 할당된다.  새롭게 생성한 파일 시스템의 Inode 수를 튜닝하여 최적화 시킬 수 있다.
    7. 디스크 성능과 용량측정 툴:  디스크의 용량을 모니터하는데 있어 가장 쉽게 사용할 수 있는 툴 중의 하나가 df이다. df는 마운트되어 있는 파일 시스템 각각의 전체 용량을 보여줄 뿐만 아니라 현재의 사용량과 이용 가능한 공간까지 알려준다. 최소 여유 공간이라고 부르는 파일 시스템의 예약된 공간이 있는데 이는 권한이 없는 프로세스의 폭주로 인하여 /나 /var와 같은 중요파일 시스템이 가득 차는 것을 미연에 방지해준다.  `/sbin/dumpe2fs /dev/hda7 |  grep Reserved`. Inode는 유닉스 파일 시스템에서 가장 가치있는 필수품이다. Inode를 다 사용한 파일 시스템이라면 다른 Inode가 삭제될 때까지 파일이나 디렉토리를 새로 생성할 수 없다. df 명령어를 사용하여 각 파일 시스템의 사용량을 출력할 수 있으나 운영체제에 따라 다른데 보통은 `df -i`이다.
    8. 크기가 큰 파일과 디렉토리의 위치 찾기: 파일 시스템의 디스크 사용량을 줄여야 하는 경우, 첫 번째로 많은 양의 공간이 사용되고 있는 곳이 어디인가를 알아내야 한다. 이 작업은 find와 du 명령어를 이용하면 된다. 1MB를 넘는 파일을 찾는 명령어 `find /usr/local -size +2000` 단위가 512바이트 블록이다.du명령어를 이용하여 디렉토리내의 파일이 사용하는 총 사용량을 출력할 수 있다. 파일 시스템의 최상위 디렉토리에서 du명령어를 사용하면 어디에서 과도한 사용을 하고 있는지 알 수 있을 것이다. -o 옵션을 사용하면 크기를 계산할 때 서브 디렉토리의 콘텐츠를 무시하게 되며, -k옵션은 결과를 킬로바이트 단위로 출력하게 된다. 출력을 sort와 head 명령어로 파이프하면, 솔라리스 서버의 /usr/local에서 가장 높은 디스크 사용량을 보이는 5개의 디렉토리를 찾아 낼 수 있을 것이다. `du -k /usr/local | sort -n -r | head -5` -n은 numeric sort이고 -r은 리버스.
    9. iostat를 이용한 디스크 활동 상태 측정: iostat 디스크와 터미널 그리고 테이프 성능을 모니터할 수 있다.
    10. sar를 이용한 디스크 성능 히스토리 분석: sar를 이용하면 cpu활용도를 분석하는 것처럼 디스크 성능 또한 히스토리화하여 분석할 수 있다. 

5. 디스크 성능과 파일 시스템 튜닝
    * 파일 시스템에 있는 데이터를 상당히 많이 이용하기 때문에 파일 시스템과 디스크를 적합하게 튜닝하는 것이 cpu를 튜닝하는 것보다 전체 시스템 성능에 있어 더 큰 영향을 주게 된다. 튜닝하는 방법은 다음과 같다
        * 고속의 디스크 사용
        * 파일 시스템을 디스크 상의 최적 위치에 배치
        * RAID-0(스트리핑) 사용
        * 파일 시스템의 Inode 수 최적화
    1. 고속의 디스크 사용
        1. 디스크 플래터의 회전율은 얼마나 빠른가가 중요한 요소이다.
    2. 최적 실린더 위치에 파일 시스템 배치
        1. 활동이 많은 디스크에서 파일 시스템의 물리적 위치는 성능에 지대한 영향을 미친다. 디스크의 바깥쪽 트랙은 안쪽의 트랙보다 더 많은 섹터를 가지게 되므로 더 많은 데이터를 가질 수 있다. 디스크의 회전 속도는 전체 디스크 반경에 걸쳐 일정하므로 안쪽의 트랙에서 읽을 수 있는 것보다 바깥 쪽의 트랙에서 더 많은 데이터를 같은 시간에 읽을 수 있다. 그러므로 바깥 쪽에는 데이터베이스의 데이터 파일과 같은 순차 접근의 패턴을 가진 데이터가 적합하다. 또한 스왑공간도 좋다. 자주 쓰는 파일 시스템을 가깝게 위치시켜 seek time을 개선할 수 있다.
    3. 다중 디스크(RAID-0)를 통한 데이터 스트리핑
        1. 스트리핑은 데이터를 여러개의 드라이브로 분산시킴으로써 효율을 증가시켜 주며 단일 i/o 연산 시 각 드라이브가 병렬적으로 데이터에 접근할 수 있도록 해준다.
    4. 파일 시스템의 지원 Inode 수 최적화
        1. 많은 운영체제가 파일의 평균 크기를 매우 작게 취하고 있으며 필요 이상으로 파일 시스템에 많은 Inode를 할당하고 있다. 이런 Inode당 평균 바이트 수를 지정함으로써 Inode 수를 최적화 할 수 있다.
6. 저장장치의 요구사항 계획
    * 시스템을 원활하게 가능하도록 유지하기 위해서는 저장 장치 수요의 갑작스런 증가뿐만 아니라 조직의 장기적인 저장 장치 요구사항에도 대비해야 한다. 이를 위해 디스크 자원의 적절한 배치, 시간에 걸친 이용경향 모니터링, 사용자 데이터와 일반적인 파일 시스템이 이용할 수 있는 공간을 동적으로 제어할 수 있게 해주는 쿼터(quota)와 LVM(logical volume manager)과 같은 운영체제의 특성을 이용하는 것이 포함된다.
    1. 디스크 이용 경향 모니터: 디스크 공간 활용도는 급격한 성장과 장기적인 성장 결과를 모두 고려해야한다. 급격한 성장을 막기위해 최소 20% 여유 공간을 유지하고, 장기적인 성장은 MRTG나 RRDtool과 같은 SNMP기반 툴을 사용하여 쉽게 할 수 있다.
    2. 각 파티션에 충분한 공간 할당: 파일 시스템은 전형적으로 고정된 크기의 파티션에 존재한다. 한번 생성하면 파일 시스템의 크기를 증가시키거나 감소시키기가 쉽지 않다. 그래서 파일 시스템의 요구사항을 잘 파악하여 공간을 할당해야한다.
    3. Extent  기반의 볼륨 매니저 활용: logical volume manager라고도 알려진 extent기반의 볼륨 매니저의 확산으로 파티션의 크기에 대한 문제가 없어지고 있다.
    4. 사용자의 공간 사용을 제한하기 위해 쿼터(quota) 이용: 파일 시스템 쿼터는 시스템 내의 특정 사용자나 그룹에게 블록 수와 Inode수를 제한하여 할당하여 한 사용자가 과도하게 디스크를 사용하는 것을 방지해 준다.
 


9-iostat
| 단위 | 설명  |
| --- | --- |
| r/s | 초당 읽기 연산 수  |
| w/s | 초당 쓰기 연산 수 |
| kr/s | 초당 읽은 킬로바이트 |
| kw/s | 초당 쓴 킬로바이트 |
| wait | 서비스되기 위해 기다린 트랜잭션의 수 |
| svc_t | 평균 서비스 시간 |
| %w | 트랜잭션이 대기한 시간의 백분율 |
| %b | 디스크가 사용중인 시간의 백분율 |    

10-sar

| 단위 | 설명 |
| --- | --- |
| %busy | 사장치가 사용 중인 시간의 백분율 |
| avque | 장치의 큐에 있는 평균 트랜잭션 수 |
| r+w/s | 초당 읽기와 쓰기 연산 수 |
| blks/s | 초당 전송된 512바이트 블록수 |
| avwait | 장치의 평균 대기 시간(ms) |
| avserv | 요청에 대한 평균 서비스 시간 |


* RAID 0(스트라이핑): 데이터를 분산된 블록으로 나눠서 저장되어 읽기 및 쓰기가 병렬로 수행될 수 있다. 제일 빠른 RAID임
![image](https://www.intel.com/content/dam/support/us/en/images/chipsets/imsm/sb/img/raid2.jpg)

* RAID 1(미러링): 모든 데이터가 중복하여 복제된다. 이점은 데이터 안정성을 제공한다.
![image](https://www.intel.com/content/dam/support/us/en/images/chipsets/imsm/sb/img/raid3.jpg)

* RAID 5(패리티가 있는 스트라이프): 데이터를 관리 가능한 하는 블록으로 나눈 3개 이상의 하드드라이브이다. 이점은 저장 용량과 데이터 보호이다. 패리티는 단일 드라이브에서 손실 된 데이터를 다시 만드는 수학적 방법이다. 또한 동시에 읽고 쓰기도 가능하다.
![image](https://www.intel.com/content/dam/support/us/en/images/chipsets/imsm/sb/img/raid5.jpg)

* RAID 10: 4개의 하드 드라이브를 사용하여 두 RAID1 어레이에서 RAID 0 어레이를 구성함으로써 RAID 레벨 0과 1의 조합을 생성한다.
![image](https://www.intel.com/content/dam/support/us/en/images/chipsets/imsm/sb/img/raid10.jpg)


|  | 0 | 1 | 5 | 10 |
| --- | --- | --- | --- | --- |
| 최소드라이브개수 | 2 | 2 | 3 | 4 |
| 활용 | 최고속도 | 데이터 중복 | 많은 용량 | 읽기성능, 데이터 중복 |
| 결함허용 | 손실 | 복제가능 | 패리티로 복구 | 복제가능 |
| 응용 | 데스크톱, 워크스테이션 | 고 가용성 | 많은 양 데이터 | 데이터보호, 고성능|
