---
layout: posts
title: chapter13. System Security
date: 2019-02-26 15:41:36 +0900
type: posts
published: true
comments: true
categories: [se]
tags: [System, Server]
---


* 학습목표
    * 인증, 인가, 계정을 통한 접근 제어하기
    * 여러 보안 유형
    * 최소 권한의 개념
    * 서비스를 분리해야만 하는 이유
    * root 계정의 관리 방법
    * 권한을 위임하는 방법
    * 익스플로잇과 공격
    * 암호화
    * 대체 인증 방법
    * 시스템 보안을 향상시키는 완전한 방법
    * 보안 문제를 논하는 보안 포럼

1. 인증, 인가, 계정(AAA-authentication, authorization, accounting): **인증(authentication)은 시스템에게 서비스 사용자라는 것을 파악시키는 과정**이다. 대부분의 시스템들은 인증자를 필요로 하며, 일반적으로 확인자와 비밀적인 코드의 조합이다. 보통 패스워드형태를 띠게 되지만 대안으로 전자 인증서, 스마트 카드, 생체인식이 일반화되고 있다.인증은 단지 서비스를 받으려고 접근하는 사용자의 신분을 입증하는 역할을 하는 것이며, 사용자가 서비스를 이용할 수 있도록 인가하는 것은 아니다. **서비스를 받으려는 사용자의 신분과 사용자의 접근 권리를 결합한 추가적인 매커니즘이 필요하게 된다. 이것이 인가(authorization) 매커니즘**이다.예로는 계정을 가진 사용자가 FTP 서비스에 접근 못하도록 하는 방법은 사용자명을 /etc/ftpuser라는 파일에 추가하면 ftp 서버에 성공적으로 인증을 받을 수는 있지만 ftp서버에는 접근 못하도록 거부할 수 있게된다. **계정(accounting)은 인증과 인가 매커니즘에 요약 정보 기능과 로깅 작업 기능뿐만 아니라 애플리케이션에 특정적인 사용 데이터 기능을 제공**한다. 계정은 시스템에 대한 접근 감사와 사용에 기반한 책임 평가에 중요한 역할을 한다. 계정이 없다면 누가 시스템에 로그인 했는지, 했었는지 알 수가 없다.
2. 유닉스 시스템의 보안 유형이 바깥으로는 빌딩 보안에서부터 안으로는 케이블 작업까지 여러 계층의 보안이 기술 인프라에 적용된다. 모든 유직스 시스템 관리자가 정통해야만 하는 세 가지의 보안 유형은 다음과 같다.
    1. 물리적 보안: 물리적인 보안은 빌딩의 주변부터 시작한다. 빌딩으로의 접근을 제어하고 내부로 들어오려는 사람들을 인증하는 것이 필요하다. 물리적인 보안은 모든 시스템의 보안에 있어 필수적이다. 애플리케이션과 운영체제에 구현된 향상된 보안 특성도 만일 그것을 구동하는 컴퓨터에 대한 물리적인 접근이 제한되지 않는다면 별 영향을 미치지 못할 것이다. 데이터 센터에서 일할 필요가 있는 종업원만 들어올 수 있게 허용함으로써, 물리적 보안을 기초적으로 구현할 수 있게 된다. 또한 많은 하드웨어 벤더들이 서버의 세시와 디스크어레이 등에 잠금장치를 설치하기도하고 접근카드, 감시카메라 등을 이용해 로그를 남기기도 한다.
    2. 네트워크 보안: 네트워크 보안은 어느 데이터가 시설 내외로 들어오고 나갈 수 있는지 제어하는 것이다. 네트워크의 첫 번째 방어선은 파이어월이거나 라우터 둘 중 하나일 것이다. 라우터의 기본 목적은 라우터 인터페이스를 통해 트래픽을 최선의 경로로 라우팅해주는 것이다. 대부분의 라우터는 포트 필터링 기능도 제공하는데, 이 기능으로 네트워크에 들어오도록 허용된 트래픽의 포트, 출발지 주소, 목적지 주소를 구별할 수 있다. 파이어월도 같은 작업을 수행하지만, 파이어월의 하드웨어는 제 4계층 필터링 작업에만 전념한다. 파이어월은 또한 기형으로 조작한 ip패킷 공격이나 syn 패킷 플러딩 공격과 같은 일반적인 네트워크 공격의 방어 기능을 제공한다. 많은 제 4계층 필터들은 smtp,http,ftp와 같은 프로토콜 내에서 발생할 수 있는 애플리케이션에 특정적인 공격을 감시한다. 제 4계층 필터들이 없었다면 모든 ip 트래픽이 시스템에서 운영 중인 네트워크 서비스에 도달했을 것이며, 인터넷에 있는 모든 사람에게 원격 접근이나 익스플로잇을 할 수 있도록 시스템을 열어 놓았을 것이다. 다른 네트워크 보안 매커니즘으로는 침입탐지가 있다. 침임탑지 시스템은 네트워크 트래픽을 모니터링에만 전념하게 되는데, 네트워크 서비스에서 이루어지는 공격의 속성 패턴을 이용한다. 의심스러운 활동이 탐지되면 관리자에게 이메일을 보내거나 무선호출을 할 수 있으며, 어떤 것은 파이어월과 같이 작용하여 공격 중인 트래픽을 차단하기도 한다.
    3. 호스트 보안: 트래픽이 네트워크 보안 장벽을 지나쳐 통과했다면, 네트워크에 있는 개개인의 호스트에 도달하게 된다. 호스트 보안의 목표는 시스템에 있는 파일이나 서비스에 허가받지 않은 사람이 접근하지 못하도록 방지하는 것이다. 호스트 보안은 로컬 레벨에서나 원격 레벨에서 운용할 수 있다. 원격 호스트 보안은 다른 컴퓨터에서 오는 허가받지 않은 접근을 방지하기 위해 네트워크 서비스를 강화하는데 초점을 둔다. 로컬 호스트 보안은 이미 시스템에 로그인한 사용자로부터 로컬 자원을 보호하는 것이다. 둘다 데이터를 보호하고 익스플로잇과 서비스 거부 공격을 방지하는 일을 한다. 일반적인 익스플로잇이나 전체 시스템을 위험에 노출되도록 열어 놓을 수 있는 설정 상의 오류에 대비하기 위해서, 특권 사용자 계정으로 가동되는 애플리케이션이나 네트워크를 통한 애플리케이션을 안전하게 할 필요가 있다.
3. 최소 권한의 이해: 보안에 있어 가장 기본적인 개념 중 하나가 최소 권한이다. 특히 유닉스 같은 다중 사용자 시스템에 있어서는 더욱 그러하다. 최소 권한이란 사용자는 그들이 일상 작업을 수행하는데 필요한 만큼의 권한만을 가져야 한다는 것을 말한다. 
4. 서비스 분리: 서비스 분리는 유닉스 시스템의 보안을 담당한 사람들에 있어 또 하나의 중요한 개념이다. 이 개념의 기초는 다른 목적을 갖는 서비스는 각자 별개의 시스템에서 해야 한다는 것이다. 이렇게 함으로써 하나의 서버가 타협을 당하더라도 시스템의 위협을 최소화할 수 있다. 
5. root 계정 관리: root계정은 유닉스 운영체제 상에서 가장 강력한 계정이며, 시스템 관리자는 이것을 주의 깊게 보호해야만 한다. 서투르게 관리되는 root계정은 갑작스런 시스템 설정 파일의 변경부터 전체 파일 시스템의 삭제까지 모든 종류의 문제로 통하게 된다.root는 자유롭게 어떤 로컬파일이라도 보거나 변경할 수 있으며, 컴퓨터의 안과 밖을 흐르는 네트워크 트래픽을 스니핑할 수 있기 때문이다. 시스템관리자로서 root계정을 적절하게 관리할 수 있는 기법을 숙지해야한다.
    1. root의 패스워드에 대한 접근 제한: 시스템 root 계정의 패스워드를 주의 깊게 보호해야 한다. root의 패스워드는 오로지 시스템의 관리 책임이 있는 사람만이 알고 있어야 한다. 대부분의 다른 특권이 필요한 작업을 수행 시 그룹 허가권이나 일반 사용자를 대신하여 root로서 명령을 실행할 수 있도록 해주는 프로그램을 설치하여 사용한다.
    2. root의 안전한 패스워드 선택: root 계정을 보호하기 위해서 할 수 있는 가장 중요한 일 중의 하나가 안전한 패스워드를 선택하는 일이다. 
    3. 투명한 접속 채널에서 root 패스워드 전송금지: 주의를 기울여 선택한 root의 패스워드라도 암호화되지 않은 네트워크를 통해 전송된다면 위험에 노출될 수 있다. 서버의 root권한을 획득한 해커가 가장 먼저 하는 일 중 하나는 미래의 접근을 목적으로 네트워크 스니퍼 프로그램을 설치하여 사용자명과 패스워드를 알아내는 일이다. 그러므로 암호화되지 않은 네트워크를 통해 root의 패스워드를 명백하게 전송하는 것은 허브 환경에서는 위험한 것이다. 왜냐하면 허브에 연결된 모든 디바이스들이 네트워크 트래픽을 볼 수 있기 때문이다. 이에 대한 해결책으로 접속시 ssh, vpn 또는 그 외 다른 수단을 통해 암호화한 접속을 함으로써 스니퍼에 취약하지 않도록 해야한다.
    4. root계정에게만 UID 0번 사용: root계정의 진정한 관리 특권은 사용자명 root라는 이름에 존재하는 것이 아니다. 그것은 계정에 할당된 사용자 ID 0번에 있는 것이다. 어느 경험이 없는 관리자가 추가 계정을 하나 생성하고 UID 0번을 부여한 후 다른 사람들이 그것을 사용할 수 있도록 결정하였다. UID 0번이 root 특권의 사용을 감사할 수 있는 방법을 제공한다고 생각했기 때문이다. 그러나 이 설정은 몇 가지 문제를 드러내게 된다. 첫번째 문제는 관리자가 다른 사용자를 root로 만들게 한 것이며, 이것은 앞의 섹션에서 설명한 바와 같은 이유 때문에 매우 위험한 것이다. 두번째는 root의 패스워드 한개를 관리하는 대신에 관리자는 이제 두개의 root 패스워드에 대해 마음을 졸여야 하며, 누가 두번째 피스워드를 알고 있는 지 조차 모르게 될 것이다. 
    5. root계정의 원격 접속 제한: root 권한으로 원격 명령어를 실행하는 많은 방법을 살펴보았다. 이러한 능력은 시스템 관리자에게 매우 유용하지만, 주의를 가지고 다르어야만 한다. root로서 원격 명령어를 실행하는 것은 패스워드 없이 root의 접근을 헝요하는 것이기 때문이다. root의 접근을 구현할 때 다음과 같은 방법으로 위험을 최소화할 수 있다. 
        1. 한 대의 컴퓨터로 root의 원격 접근을 제한한다. 안전하게 중무장한 게이트웨이를 한대 만들어서 원격의 root 계정을 만들어준다.
        2. 원격 시스템에 root의 접근을 얻기 위해서는 게이트웨이 시스템의 root 접근을 요구한다. 이러한 예방 조치는 게이트웨이에 다른 층의 보안을 추가하는 것이며, 오직 시스템 관리자만이 원격 root접근을 이용할 수 있다는 것을 보증해준다.
        3. ssh의 공개키 인증 방식과 같은 강력한 인증 방식에 덧붙여 다른 신뢰할 만한 호스트 메커니즘을 사용한다. 이러한 2계층 접근 보안은 누군가가 관리자와 사용자의 신원을 스푸핑하는 위험을 감소시켜준다.
6. 권한 위임: 이전까진 어떤 일이 있더라도 root의 권한을 보호해야 한다는 것에 대한 중요성을 강조하는데 시간을 할애하였다. 그러나 이제는 일반 사용자에게권한을 위임하는 것이 적절하고 심지어는 필요하다는 것을 설명해야 할 시간이다. 권한을 안전하게 위임해주는 aliases와 defaults를 포함하여, 접근제한, 그룹 허가권 이용 등의 툴과 방법을 사용할 수 있어야 한다.
    1. sudo를 이용하여 다른 사용자 권한으로 명령 실행하기: sudo는 시스템 관리자가 이것을 특정 작업을 위해 root의 특권을 위임하는데 일상적으로 사용하는 명령어이다. 하지만 원래는 한 사용자를 다른 사용자의 권한으로명령어를 실행할 수 있게 해주는 명령어이다. sudo는 관리자들 사이에서 root의 특권을 위임하는데 사용하는 가장 대중적인 써드 파티 툴이다. sudo는 다음과 같은 특성을 지원한다.(중앙 집중적인 설정파일, 사용자, 그룹, 호스트 별로 특정 명령어에 대한 실행제한, 패스워드 인증, 명령어 감사를 위한 로깅작업). sudo 명령어의 설정 파일은 /etc/sudoers 파일이며, 반드시 visudo명령어를 사용하여 편집해야한다. sudoers파일은 다음과 같이 세 개의 주요 부분으로 구성되어 있다.
        1. Aliases: sudoers 파일의 aliases 섹션은 사용자,  호스트, 명령어의 리스트를 정의하는 부분이며, 이후의 참조에 사용하게 된다. 4가지 유형의 aliases 리스트 항목이 있다.
            1. User_Alias: sudo 명령어를 실행할 수 있는 사용자들
            2. Runas_Alias: 명령어를 실행할 때 대체할 사용자들
            3. Host_Alias: 사용자가 sudo로 명령어를 실행시킬 수 있는 호스트들
            4. Cmnd_Alias: sudo로 실행되는 명령어들
        2. Defaults: 디폴트 섹션은 관리자로 하여금 sudo의 기본 세팅을 유연한 방법으로 변경할 수 있도록 해준다. sudo는 여기서 열거하기에는 너무 많은 기본 세팅 값을 가지고 있긴 하지만, 흥미있는 몇 개만 살펴보기로 한다.
            1. timestamp_timeout: 패스워드 요청의 간격 시간
            2. logfile: 로그파일이 저장될 경로
            3. mailto: 에러와 경고 메시지를 보낼 어드레스
        3. User Specification: 이 섹션은 어떤 명령어를 사용자가 실행할 수 있는지 실제로 지정하는 부분이며, 이용하는 사람이 어떤 사용자로서 명령을 실행할지 지정하는 곳이다. `ID 호스트 = (사용자) 명령어` 예를 들면 `jeff server1 = (root) /bin/ls, /bin/kill`는 서버1이라는 시스템에 있는 사용자 jeff가 명령어 ls와 kill을 root권한을 가지고 실행할 수 있게 해준다.
    2. 유닉스의 그룹 허가권을 이용한 파일 편집: root의 접근이 필요하다고 사용자들이 믿는 대부분의 작업들은 재치있게 그룹 허가권을 조작함으로써 실제로 실행될 수 있다. root의 권한을 필요로 하는 작업들이 대부분이 root소유의 파일을 읽거나 편집하기 위해서이다. 그러나 그러한 파일들이 시스템 안정성 면에서 중요하지 않은 것들이라면, 그 파일들에 새로운 그룹을 할당하고 그 그룹에 읽기 허가권과 쓰기 허가권을 주면 된다. 이 그룹 허가권은 root는 물론 그룹에 속한 사용자들이 해당 파일을 읽고 쓸 수 있게 해준다. 그룹 허가권이 유용하게 사용될 수 있는 좋은 예가 아파치 웹 서버의 주 설정 파일인 httpd.conf이다. 이 설정 파일의 기본 허가권은 레드햇 리눅스의 경우 다음과 같다. `-rw-r--r-- 1 root root 33998 Jul 17 2001 httpd.conf` 이 파일은 모두가 읽을 수 있지만 쓰기는 오직 root에 의해서만 가능하다. 이러한 설정은 웹 마스터가 이 파일을 편집하려 하는 경우, 웹 마스터에게 sudo 등을 이용하여 root의 특권을 주어야만 할 것이다. 웹 마스터가 시스템의 관리자가 아니라면, 아마도 그에게 root의 특권을 주기를 원치 않을 것이다. 그러므로 웹 서버 설정 파일을 편집할 수 있는 유닉스 스룹을 생성하여 처리를 할 수 있다. `chmod 소유자/그룹/공개 값 파일이름 chown 사용자.그룹 파일이름`
7. 익스플로잇과 공격: 유닉스 시스템에서 가장 일반적인 공격 유형이 익스플로잇과 서비스 거부 공격이다. **익스플로잇은 프로그램의 버그와 잘못된 설정을 이용하여 허가받지 않은 접근**을 얻는 것이며, **서비스 거부 공격은 서비스를 이용 불가능한 상태로 만드는 것**이다.
    1. 의심스러운 활동 탐지: 의심스러운 활동을 탐지하는데 있어 가장 강력한 툴 중 하나가 자신의 시스템을 정통하게 아는 것이다. 시스템을 잘 알게 될 때, 이러한 일반 수준에서 벗어나는 것들을 알아차리게 된다. 하루 일정 시간을 내서 시스템을 미리 그리고 손으로 직접 점검하기 바란다. df명령어를 사용하여 파일 시스템의 용량을 확인하고, uptime 명령어로 부하 평균을 살피고, ps명령으로 가동 중인 프로세스를 알아낸다. 
    2. 설정상의 오류: 유닉스는 여러 가지 방법으로 운영체제가 설정이 가능한데 이에 따라 잠재적인 공격에 노출되는 설정을 하게 될 수도 있다. 하지만 이런 불안정한 설정을 검사해주는 몇개의 프로그램이 있으므로 참고하자. 예를 들면 일시적으로 무제한 원격 접근을 위해 /etc/hosts.equiv에 +을 추가하고 나중에 까먹은 경우
    3. 쉘의 특수 문자 이용: 정규표현식 같은 것을 이용해 변수에 문자나 숫자가 아닌 문자가 포함된 경우 system 함수가 실행되는 것을 막아 큰 사고를 줄인다. 예를 들면 `ps -fu $username`에서 username 변수에 mike;rm -rf /를 하면 뒤에 명령어가 실행이 되버림 
    4. 쉘 이스케이프: 일부 명령어는 명령어 프로세스 내에서 쉘을 불러 다른 명령어를 실행할 수 있다. 만일 sudo를 이용해서 사용자에게 root로서 파일을 편집할 수 있게 해놓았다면, 사용자들이 root로서 어떤 명령어라도 실행할 수 있도록 허용한 것이다. 예를 들면 vi의 ex모드에서 ! ls를 입력하면 서브쉘로 ls명령어가 실행되고 그 결과를 보여준다. 이를 막기위해 sudo 설정파일, /etc/passwd 파일 내의 사용자가 지정한 쉘뿐만 아니라 setuid 프로그램들까지 점검해야한다.
    5. 버퍼 오버플로우: 버퍼 오버플로우는 가장 대중적이었던 익스플로잇이다. 이 익스플로잇은 C가 버퍼의 마지막 경계 부분을 지나쳐 쓰는 것을 막지 못하는 점을 이용한다. 이를 이용해 root접근 권한을 얻을 수 있게 된다.
    6. 잘못된 패스 검증: 잘못된 패스 검증은 유닉스 프로그램을 작성할 때 일어날 수 있는 가장 일반적인 프로그래밍 실수 중의 하나다. 예를 들어 어떤 파일을 조회할 수 있게 open file /var/log/$logname이라 하면 로그이름을 쓰지 않고 ..을 쓰면은 이전 디렉토리로 올라가 중요한 /etc/passwd와 같은 중요한 파일을 읽을 수 있게 된다. 
    7. ip스푸핑: 네트워크 트래픽은 익스플로잇에 면역력이 없다. 실제로 IPsec이나 다른 보안 메커니즘으로 암호화되지 않은 전체 ip프로토콜은 매우 취약하다. ip 스푸핑은 네트워크를 익스플로잇하는데 아주 쉽게 사용할 수 있는 방법 중 하나이다. ip스푸핑은 위조된 출발지 주소를 갖는 조작된 ip패킷이 시스템 상에서 유효하게 작동하는 것이다. 전형적으로 해커들은 다음의 목표 중 하나를 성취하기 위해 이 익스플로잇을 이용한다(주소 기반의 접근 매커니즘을 사용하는 시스템으로의 접근 획득, 진행중인 공격의 실제 근원지를 은폐,스푸핑된 출발지 주소를 배경으로 분산 서비스 거부 공격). 이를 막기 위해 라우터나 파이어월을 설치함으로써 자신의 내부 네트워크 주소를 출발지 주소로 가지고 들어오는 패킷을 거부할 수 있다.
    8. 서비스 거부 공격(Dos: Denial of Service): 서비스 거부 공격은 조직에서 일어날 수 있는 가장 심각한 악질적인 일 중에 하나이다. 이러한 공격은 서버를 슬모 없는 지점에 이르기까지 다운시킨다. 서비스 거부 공격은 일반적으로 서비스 요청 플러딩으로 구성되어 있으며, 결국은 하나 이상의 시스템에서 이용 가능한 자원 모두를 소진시킨다.
        1. syn플러딩 공격: ip가 위조된 syn패킷을 계속 서버에 전달 서버는 ack로 응답하지만 syn/ack가 오지 않는다 그래서 이 패킷을 받는 것을 기다리는데 자원을 이용 결국 서버는 네트워크 자원을 모두 소비하고 실질적으로 필요한 네트워크 접속이 불가해진다.
        2. 스머프(smurf) 공격: 스머프 공격은 분산 서비스 거부 공격의 한 유형이다. 스머프 공격은 icmp echo 요청을 다른 네트워크의 브로드캐스트 주소로 직접 전송하는데, 이렇게 되면 네트워크에 있는 모든 호스트들에게 icmp 패킷을 브로드캐스트한다.일반적으로 이런 광범위 브로드캐스트 요청은 개시한 시스템으로 응답이 홍수처럼 몰려들게 된다. 그러므로 이 요청하는 출발지 주소필드에 공격하려는 시스템의 ip를 넣어 엄청난 응답을 받게 한다.

